# 性能优化

## 图片优化

**图片懒加载**

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
    + 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP
      格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好 `在服务端根据请求header信息判断浏览器是否支持webp`
    + 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
    + 照片使用 JPEG

## DNS预解析

> DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP

```html

<link rel="dns-prefetch" href="//yuchengkai.cn">
```

## 节流

> 考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流

```js
// func是用户传入需要节流的函数
// wait式等待时间
const throttle = (func, wait) => {
  let lastTime = 0; // 上一次执行该函数的时间
  return function (...args) {
    // 当前时间
    let now = +new Date();
    // 将当前时间与上一次执行时间对比，如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now;
      func.apply(this, args);
    }
  }
}

setInterval(throttle(() => {
  console.log(1)
}, 500), 1)
```

## 防抖

> 考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0;
  // 这里返回的函数是每次用户实际调用的防抖函数,如果已经设定过定时器了就清空上一次的定时器,开始一个新的定时器，延迟执行用户传入的方法
  return function (...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}
```

## 预加载

> 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载。
`预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。`

```html

<link rel="preload" href="http://example.com">
```

## 预渲染

> 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染
`预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染`

```html

<link rel="prerender" href="http://example.com"> 
```
